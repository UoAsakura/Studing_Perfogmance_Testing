
Напишите определение для каждого принципа ООП:
*
Абстракция - сокрытие сложных деталей, оставляя ключевые механики. В Java это достигается с помощью абстрактных классов и интерфейсов.

Инкапсуляция - доступ к данным через публичные методы, для их защиты, при этом скрывая их внутреннюю реализацию.

Наследование - создание нового класса, на основе уже существующего. Класс-наследник получает все свойства и методы класса-родителя с возможностью их переопределения, а также может добавлять новые.

Полиморфизм - возможность реагирования разных классов, на одно и то же сообщение (вызов метода класса).

Композиция - подразумевается, что класс может включать в себя другие объекты, что позволяет создавать более сложные структуры данных из простых. 
Чем класс отличается от объекта?
*
Класс является абстрактным представлением структуры (шаблона), с набором свойств и методов, а также возможностей и ограничений по взаимодействию с ним.
Объект же, посредством инициализации (привязывания) себя к классу, является его реализацией (экземпляром), с которой уже можно взаимодействовать в рамках методов и свойств класса.
Чем отличается абстрактный класс от интерфейса?
*
Абстрактный класс отлично подходит, когда нужно обеспечить общее поведение с некоторыми реализациями, а интерфейс, чаще применяется, если нужно определить разным классам наборы методов и их реализацию.
Есть ли в Java множественное наследование классов?
*
Множественного наследования нет, но можно достигнуть схожего поведения, как раз с помощью интерфейса.
Назовите методы класса Object:
*
public String toString()
public int hashCode()
public boolean equals(Object obj)
protected void finalize() 
protected Object clone()
public final Class<?> getClass() 
public void notify()
public void notifyAll()
public final void wait()
public final void wait(long timeout) 
public final void wait(long timeout, int nanos)
Есть ключевые слова THIS и SUPER. Для чего они используются?
*
Слово this (аналог self в Python) - используется для ссылки на текущий объект класса.
Позволяет различать параметры и поля, вызывать другие конструкторы и передавать текущий объект.

Слово super (аналог super в Python) - ссылается на родительский класс, позволяет получать доступ к его методам и полям, а также вызывать его конструкторы.
Есть конструкция switch-case. Что это за конструкция? Для чего там нужен оператор break?
*
switch-case является альтернативой использования операторов if-else, когда нам нужно проверить определённое выражение (условие), на соответствие нескольким значениям. Одно из преимуществ перед if-else, является улучшенная читаемость в определённых случаях.

break же, является оператором остановки проверки условия, для предотвращения "провала" в нежелательный блок кода. Помогает обеспечить корректное завершение всего блока условий.
Какой метод нужно использовать, чтобы преобразовать строковое значение в int?
*
parseInt() (класса Integer)
Вам пришел список данных - телефонные номера. Они могут повторяться. Вы хотите получить только уникальные номера. Как в Java это сделать?
*
Использовать одну из реализации коллекции работающей по принципу HashMap, например, HashSet. Данная структура данных устроена следующим образом, она не позволяет хранить в себе идентичные объекты и при обнаружении дубликата, оставляет только один их них.
Что такое pom-файл?
*
Файл POM, чаще называемый pom.xml, содержит информацию о проекте и конфигурацию для сборки, управления зависимостями, плагинами и другими аспектами проекта. Помогает оптимизировать разработку проекта использующих Maven.
Как устроена JVM?
*
JVM интерпретирует байт-код, который сгенерирован компилятором Java (javac) на основе Java-программ и после отвечает за его выполнение на конкретной платформе.

JVM состоит из:
 - Class Loader (Загрузчик классов) - Загружает классы в память.
 - Execution Engine (Движка выполнения) - Исполняет загруженные классы.
 - Runtime Data Areas (Области данных времени выполнения) - Временные хранилища данных.

Также в JVM реализован Garbage Collector (сборщик мусора), который автоматически управляет памятью и удаляет не использующиеся (на которые нет ссылок) объекты.
Какие области памяти у JVM?
*
Методная область (Method Area) - Хранит данные о классах, такие как метаданные, код методов, константы и статические переменные.

Куча (Heap) - Основная область памяти для динамического выделения памяти, используется для хранения объектов.

Стек (Stack) - Используется для хранения локальных переменных, информации о вызовах методов и управления выполнением программы.

Регистры программного счетчика (PC Registers) - Хранят адрес текущей выполняемой инструкции для каждого потока.

Стек нативных методов (Native Method Stack) - Используется для хранения информации о вызовах нативных (не-Java) методов, таких как методы, написанные на C или C++.
Какие поколения есть в Java Heap?
*
 - Молодое поколение (Young Generation) - объекты, которые не переживут сборку мусора.
 - Старое поколение (Old Generation) - объекты, которые переживут множество итераций сборки мусора.
 - Постоянное поколение (Permanent Generation / Metaspace) - хранение метаданных.
Как работает GC? Как определяет, какие объекты оставить, а какие удалить?
*
Garbage Collection отслеживает объекты, которые были созданы в Java Heap, и решает, какие из них все еще доступны (используются) и какие больше не нужны.
Данное решение, помогает автоматически контролировать память и избегать её утечек.

Garbage Collection регулярно "проходится" по Java Heap и оценивает, какие объекты больше не требуются для выполнения программы. Под этим подразумевается, что на них больше нет ссылок.

Java использует несколько различных алгоритмов сборки мусора:
 - Minor GC (младшая сборка). Происходит в молодом поколении (Young Generation). Этот процесс обычно быстрый, поскольку большинство объектов в молодом поколении имеют короткий срок жизни.
 - Major GC (основная сборка). Происходит в старом поколении (Old Generation).
Более ресурсозатратный процесс, поскольку он очищает объекты, которые пережили несколько сборок мусора в молодом поколении. Может занять значительное время, и поэтому выполняется реже.

Какие бывают GC?
*
Сборщики мусора делятся по нескольким параметрам.

 - Во-первых, по возможности работы в многопоточном режиме. Пример однопоточного сборщика Serial GC и его антипод Parallel GC. 
 
 - Во-вторых, возможность параллельной сборки мусора с работой приложения (наличия времени пауз). Пример: CMS (Concurrent Mark-Sweep). То есть в данном случае, приложение не будет останавливаться для сборки мусора. Может негативно сказаться на эффективности сборки.

 - В-третьих, по частоте сборки. Не рационально выбранный GC под конкретное приложение, может слишком часто пытаться собрать мусор, а также не оптимально использовать память фрагментируя её.

GC может выбираться в зависимости от системы и приложения, т.к. они  довольно сильно отличаются между собой и по области применения.
Так же стоит помнить, что периодически выходят и новые, порой более эффективные в определённой области GC, в том числе и неофициальные. 
Поэтому их выбор всегда остаётся за разработчиком.
Почему помимо утечек нужно смотреть на то, как отрабатывает GC?
*
Наличие встроенных алгоритмов сборки мусора ещё не гарантирует, что весь мусор будет вычищаться, а занятая им память освобождаться для переиспользования. Понимание принципов работы GC помогает избежать накопления такого мусора в программе, который не будет убран автоматически.

